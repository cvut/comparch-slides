\documentclass{beamer}
%[aspectratio=169]   \usepackage[czech]{babel}
\usepackage{apo-lecture}
\usepackage{pdfpages}
\usepackage{pdfcomment}
\usepackage{listings}
\usepackage{array,multirow}

\subtitle{Lekce 03. Central Processing Unit (CPU)}
\author{Pavel Píša \phantom{xxxxxxx} Petr Štěpán \\ \small\texttt{pisa@fel.cvut.cz}\phantom{xxxx}\small\texttt{stepan@fel.cvut.cz}}
\begin{document}

\maketitle

\section{Simulátor}

\begin{frame}
\frametitle{Simulátory QtMips a QtRVSim}

\begin{itemize}
\item dříve se používalo prostředí MipsIt, které bylo ale velmi omezené
\item QtMips se pro výuku APO využívá od letního semestru 2019
\begin{itemize}
\item QtMIPS bylo vytvořeno jako diplomová práce Karla Kočího vedená Pavlem Píšou: \textit{Graphical CPU Simulator with Cache Visualization}, kterou si můžete prohlédnout \url{https://dspace.cvut.cz/bitstream/handle/10467/76764/F3-DP-2018-Koci-Karel-diploma.pdf}
\item Opravy, rozšíření a částečné přepracování Pavel Píša
\end{itemize}
\item v roce 2022 byl simulátor přepracován pro architekturu RISC-V, hlavní změny jsou od Jakuba Dupáka z jeho bakalářské práce z 2021 \textit{Graphical RISC-V Architecture Simulator - Memory Model and Project Management} odkaz:
\url{https://dspace.cvut.cz/bitstream/handle/10467/94446/F3-BP-2021-Dupak-Jakub-thesis.pdf}

\item Alternativy:
\begin{itemize}
 \item RARS: Risc-V Assembler and Runtime Simulator -- IDE založené na systému MARS \url{https://github.com/TheThirdOne/rars}
 \item EduMIPS64: simulátor napsaný v Javě \url{https://www.edumips.org/}
\end{itemize}
\end{itemize}

\end{frame}


\begin{frame}
\frametitle{QtRVSim - Download}
\begin{itemize}
\item Windows, Linux, Mac
\url{https://github.com/cvut/qtrvsim/releases}
\item  Ubuntu
\url{https://launchpad.net/~qtrvsimteam/+archive/ubuntu/ppa}
\item Suse, Fedora and Debian
https://software.opensuse.org/download.html?project=home\%3Ajdupak&package=qtrvsim
\item Suse Factory TBD
\item Online version \url{https://dev.jakubdupak.com/qtrvsim/}
\item LinuxDays 2019 QtMips talk – záznam interaktivní přednášky
\url{https://youtu.be/fhcdYtpFsyw}, \url{https://pretalx.linuxdays.cz/2019/talk/EAYAGG/}
\end{itemize}
\end{frame}

\begin{frame}[shrink=5]
\frametitle{John von Neumann}
\begin{center}
\includegraphics[width=0.5\textwidth]{cpu-vonNeumann.pdf}
\hfill
\includegraphics[width=0.2\textwidth]{fig/vonNeumann.png}
\end{center}
\begin{itemize}
\item 5 základních jednotek – řídicí jednotka, aritmeticko-logická jednotka, paměť, vstup (vstupní zařízení), výstup (výstupní zařízení)
\item Architektura počítače by neměla být závislá na řešené úloze, měla by umět provádět program uložený v paměti. Program řídí, co počítač vykonává za instrukce a tím jaké dostane výsledky.
\item Program a data jsou uložena ve stejné paměti, složené z buněk (jednotek) stejné velikosti. Oproti tomu Harvardská architektura měla jeden typ paměti pro program a jiný typ paměti pro data.
\item Další instrukce, která se bude vykonávat je uložena v následující buňce paměti (mimo skoků v programu)
\item Instrukce provádějí aritmetické a logické operace, přesuny dat z/do paměti, skoky a větvení programu a speciální řídicí instrukce.
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Počítač založený na von Neumannově konceptu}

Procesor / mikroprocesor:
\begin{itemize}
\item Řídicí jednota (control unit)
\item Aritmeticko-logická jednotka -- ALU
\end{itemize}

Paměť: 
\begin{itemize}
\item von Neumann architektura má společnou paměť pro program i data
\item paměť se skládá z buněk - jednotek, v současné době z bajtů
\end{itemize}

Vstupně výstupní podsystém:
\begin{itemize}
\item Vstupy -- klávesnice, myši, děrné štítky, magnetopáskové jednotky, síťové karty, ...
\item Výstupy -- monitory (grafické karty), tiskárny, plotry, síťové karty, ...
\end{itemize}

Řídicí jednotka řídí práci a sekvenci této práce. Skládá se z:
\begin{itemize}
\item registrů – udržují mezivýpočty a stavy výpočtů
\item řídicích hradel -- dekódují instrukce a provádí operace
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Nejdůležitější registry procesoru}
\begin{itemize}
\item PC (Program Counter) -- adresa právě prováděné (nebo následující) instrukce
\item IR (Instruction Register) -- obsahje kód prováděné instrukce načtený z paměti
\item Another usually present registers
\begin{itemize}
\item GPRs (General purpose registers) -- obecné uživatelské registry, mohou se dělit na data a adresy do paměti, nebo být univerzální
\item SP (Stack Pointer) -- ukazuje na vrchol zásobníku, slouží k organizaci lokálních dat funkcí
\item PSW (Program Status Word) -- definuje v jakém stavu je procesor
\item IM (Interrupt Mask) -- kontrola přerušení
\item FPRs (Floating point registers) -- rozšíření procesoru pro práci s reálnými čísly, případně i vektorové/multimediální registry
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Základní cyklus procesoru}
\begin{enumerate}
  \item Počáteční nastavení -- inicializace registru PC a PSW (případně i dalších) po zapnutí proudu nebo po resetu procesoru
  \item Přečti instrukci z paměti z adresy PC
  \begin{itemize}
    \item nastav PC na adresu sběrnice paměti
    \item Přečti obsah ze sběrnice paměti do registru IR
    \item $PC+l \to PC$, uprav $PC$, $l$ je délka načtené instrukce
  \end{itemize}
  \item Dekóduj instrukci
  \item Proveď instrukci
  \begin{itemize}
    \item spočti adresu, vyber registry, načti operandy, proveď požadovaný výpočet ALU a ulož výsledky
  \end{itemize}
  \item Zkontroluj zda není přerušení nebo vyjímka (podrobně v přednášce 9)
  \item Opakuj od kroku 2
\end{enumerate}
\end{frame}


\begin{frame}[fragile,shrink=10]
\frametitle{Compilation: C  Assembler  Machine Code}

\begin{columns}
\begin{column}{0.3\textwidth}
\begin{lstlisting}[language={C},columns=flexible]
/* ffs as log2(x)*/
int x = 157;
int y = -1;
 
while(x != 0) {
  x = x / 2;
  y = y + 1;
}
\end{lstlisting}
\end{column}

\begin{column}{0.4\textwidth}  
\begin{lstlisting}[language={C},columns=flexible]
_start:
    // int x = 157;
  addi a0, zero, 157  
    // int y = 0;
  addi t1, zero, -1   
    // while(x != 0) {
  beq a0, zero, done  
loop:
    //   x = x / 2;
  srli a0, a0, 1 
    //   y = y + 1;
  addi t1, t1, 1      
    // }
  bne a0, zero, loop  
done:
\end{lstlisting}
\end{column}

\begin{column}{0.3\textwidth}  
\texttt{0x00000200  09d00513\\
0x00000204  fff00313\\
0x00000208  00050863\\
0x0000020c  00155513\\
0x00000210  00130313\\
0x00000214  fe051ce3\\
0x00000218  00030513\\
0x0000021c  00100073}
\end{column}

\end{columns}

\end{frame}


\begin{frame}
\frametitle{Kódování instrukcí}

Co musíme uvažovat při návrhu zakódování instrukcí?
\begin{itemize}
\item 8 bitů pro jednu instrukci
\begin{itemize}
\item Pokud by velikost instrukce byla jeden bajt, tedy 8 bitů, tak můžeme mít maximálně 256 různých instrukcí
\item Je to dost?
\item Co vlastně musí být zakódováno uvnitř instrukce? Nutně tam musí být registry, se kterými bude instrukce pracovat
\begin{itemize}
\item pokud bychom měli v procesoru 8 registrů, pak 3 bity kódují, který registr chceme použít
\item pro operaci potřebujeme 3 registry \texttt{cíl = zdroj1 + zdroj2} nebo jen 2 registry \texttt{cíl += zdroj}
\item pro práci s pamětí stačí 2 registry \texttt{cíl = MEM[zdroj]}
\end{itemize}
\item nelze zakódovat 3 operandy, i pro 2 operandy máme jen 2 bity (8-2*3) na zakódování typu instrukce, což je maximálně 4 druhy instrukcí
\item řešení by bylo jedině mít méně registrů a uvažovat zásobníkové operace (push, pop, sečti dvě čísla z vrcholu zásobníku, apod.)
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Kódování instrukcí}

\begin{itemize}
\item 16 bitů na jednu instrukci -- 65536 různých instrukcí
\begin{itemize}
\item lze 16 registrů, 256 instrukcí s dvě operandy, nebo 16 druhů instrukcí se třemi operandy (4 + 3 * 4 = 16 bitů)
\end{itemize}
\item 32 bitů -- přes 4 miliardy různých instrukcí 
\begin{itemize}
\item často 32 registrů, až 128 tisíc druhů instrukcí se třemi operandy (17 + 3 * 5 = 32 bitů)
\end{itemize}
\item Další problém jsou konstanty, třeba chci přičíst 1 k registru, nebo uložit do registru konkrétní hodnotu 125. 
\begin{itemize}
\item překladač vygeneruje do paměti všechny konstanty a registry na ně budou ukazovat
\item nebo malá čísla budou součástí instrukce
\begin{itemize}
\item toto je nejpoužívanější řešení
\item RISC má instrukce pevné délky a součástí 32-bitové instrukce může být 20-bitová nebo 12-bitová konstanta
\item CISC má instrukce proměnné délky a třeba i 64-bitové číslo je součástí kódu instrukce
\end{itemize}
\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}[shrink=5]
\frametitle{RISC-V -- Délka instrukce}

\begin{tabular}{r l}
  \begin{tabular}{|c|}\hline
  \texttt{xxxxxxxxxxxxxxaa}\\ \hline
  \end{tabular} & 16-bit ($aa \neq 11$)\\
   &  \\
   \begin{tabular}{|c|c|}\hline
  \texttt{xxxxxxxxxxxxxxxx} & \texttt{xxxxxxxxxxxbbb11}\\ \hline
  \end{tabular} & 32-bit ($bbb \neq 111$)\\
 &  \\
   \begin{tabular}{c|c|c|}\hline
  \texttt{...xxxx} &\texttt{xxxxxxxxxxxxxxxx} & \texttt{xxxxxxxxxx011111}\\ \hline
  \end{tabular} & 48-bit\\
 &  \\
   \begin{tabular}{c|c|c|}\hline
  \texttt{...xxxx} &\texttt{xxxxxxxxxxxxxxxx} & \texttt{xxxxxxxxx0111111}\\ \hline
  \end{tabular} & 64-bit\\
 &  \\
   \begin{tabular}{c|c|c|}\hline
  \texttt{...xxxx} &\texttt{xxxxxxxxxxxxxxxx} & \texttt{xnnnxxxxx0111111}\\ \hline
  \end{tabular} & ($80+16\cdot nnn$)-bit\\
  & ($nnn \neq 111$)\\
   \begin{tabular}{c|c|c|}\hline
  \texttt{...xxxx} &\texttt{xxxxxxxxxxxxxxxx} & \texttt{x111xxxxx0111111}\\ \hline
  \end{tabular} & rezervováno pro\\
  & $\ge 192$-bit\\
Address: \phantom{\texttt{yyyyyxxxxxxxxxxxxxxxx    xxxxxxxxx0111111}}&  \\
base+4 \phantom{\texttt{xxxxxxx}} base+2 \phantom{\texttt{xxxxxxxxxxx}} base \phantom{\texttt{xxxxxxx}} &  \\
\end{tabular}

\end{frame}


\begin{frame}[shrink=12]
\frametitle{RISC-V -- Registry}
\begin{tabular}{|l|l|l|l|}\hline
Register & ABI Name & Popis & Uchování \\ \hline
x0 & zero & má vždy hodnotu 0 &  \\\hline
x1 & ra & Návratová adresa (Return address) & Volající \\\hline
x2 & sp & Ukazatel na zásobník (Stack pointer) &  Volaný\\\hline
x3 & gp & Ukazatel na globální data &  \\
   &    & (Global pointer) &  \\\hline
x4 & tp & Ukazatel na vlákno (Thread pointer) &  \\\hline
x5-7 & t0--2 & Dočasné proměnné (Temporaries) &  \\\hline
x8 & s0/fp & Uchovávaný registr (Saved register)/ & Volaný \\
   &       & Ukazatel na rámec (Frame pointer) &  \\\hline
x9 & s1 & Uchovávaný registr (Saved register) &  Volaný \\\hline
x10--11 & a0--2 & Argumenty funkce (Function arguments)/ &  Volající \\
 &  & Návratové hodnoty (Return values) &  Volaný \\\hline
x12--17 & a2--7 & Argumenty funkce (Function arguments) & Volající \\\hline
x18--27 & s2--11 & Uchovávané registry (Saved registers) & Volaný \\\hline
x28--31 & t3--6 & Dočasné proměnné (Temporaries) &  \\\hline
pc & pc & Ukazatel na instrukci (Program Counter) &  \\\hline
f0-31 &  & Reálná čísla (Floating point) &  \\\hline
\end{tabular}
\end{frame}

\begin{frame}
\frametitle{Cíl přednášky}

\begin{itemize}
\item Porozumět implementaci jednoduchého počítače, který se skládá z
procesoru a oddělené paměti pro instrukce a data
\item Naším cílem je implementovat následující instrukce:
\item Číst a zapisovat hodnotu z/do datové paměti.
\begin{itemize}
\textbf{\texttt{lw}} - načtení slova, \textbf{\texttt{sw}} - uložení slova
\end{itemize}
\item aritmetické a logické instrukce: \textbf{\texttt{add}}, \textbf{\texttt{sub}}, \textbf{\texttt{and}}, \textbf{\texttt{or}}, \textbf{\texttt{slt}}
\begin{itemize}
\item Immediátové varianty: \textbf{\texttt{addi}}, \textbf{\texttt{ori}}, horní bity načítají \textbf{\texttt{olui}},\textbf{\texttt{auipc}}
\end{itemize}
\item Instrukce pro změnu toku programu/skok \textbf{\texttt{beq}}
\item Volání podprogramu \textbf{\texttt{jal}}, \textbf{\texttt{jalr}} (zajišťuje i návrat z podprogramu \textbf{\texttt{jr~ra}})
\item CPU se bude skládat z řídicí jednotky a ALU.
\item Poznámky:
\begin{itemize}
\item Implementace bude minimální (jednocyklový procesor - všechny operace budou probíhat v jednom cyklu, tzn.
zpracovány v jednom kroku/hodině)
\item Přednáška 5 je zaměřena na efektivnější realističtější implementaci zřetězenného (pipelined) CPU.
\end{itemize}
\end{itemize}

\end{frame}


\begin{frame}
\frametitle{Kódování instrukcí procesoru MIPS}

Starší typ procesoru, má tři typy instrukcí:

\begin{tabular}{|c|l|l|l|l|l|l|}\hline
Typ & 31 ... 26 & 25 ... 21 & 20 ... 16 & 15 ... 11 & 10 ... 6 & 5 ... 0 \\ \hline
R & opcode(6) & rs(5) & rt(5) & rd(5) & shamt(5) & funct(6) \\ \hline
I & opcode(6) & rs(5) & rt(5) & \multicolumn{3}{c|}{ immediate(16)} \\ \hline
J & opcode(6) & \multicolumn{5}{c|}{ address(26)} \\ \hline
\end{tabular}

\begin{itemize}
\item typ instrukce (R,I,J) je určen 6-bity opcode
\item rs -- register zdroje -- source; rd -- register cíle -- destination; rt -- někdy zdroj, někdy cíl
\item immediate, address -- konstanty použité pro operaci, immediate pro počítání, address pro skoky 
\item shamt -- konstanta využitá pouze pro posuny (shift, operace \texttt{<<}, \texttt{>>})
\item funct -- specifikace prováděné operace, např. sčítání, odčítání, posuny, atd.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Kódování instrukcí procesoru RISC-V}

Má šest typů instrukcí:
\begin{table}
\footnotesize
\begin{tabular}{|m{0.4cm}|m{0.4cm}|m{1.0cm}|m{1.0cm}|m{0.4cm}|m{1.0cm}|m{1.0cm}|m{1.0cm}|m{0.4cm}|m{1.0cm}|}\hline
Typ & 31 & 30...25 & 24...21 & 20 & 19...15 & 14...12 & 11...8 & 7 & 6...0 \\ \hline
R & \multicolumn{2}{c|}{ fnct7 } & \multicolumn{2}{c|}{ rs2 } & rs1 & fnct3 &\multicolumn{2}{c|}{ rd } & opcode\\ \hline
I & \multicolumn{4}{c|}{ imm[11:0] } & rs1 & fnct3 &\multicolumn{2}{c|}{ rd } & opcode\\ \hline
S & \multicolumn{2}{c|}{ imm[11:5] } & \multicolumn{2}{c|}{ rs2 } & rs1 & fnct3 &\multicolumn{2}{c|}{ imm[4:0] } & opcode\\ \hline
B & imm [12] & imm [10:5]  & \multicolumn{2}{c|}{ rs2 } & rs1 & fnct3 & imm[4:1]& imm [11] & opcode\\ \hline
U & \multicolumn{6}{c|}{ imm[31:12] }  & \multicolumn{2}{c|}{ rd } & opcode\\ \hline
J & imm [20] & \multicolumn{2}{c|}{ imm[10:1] } & imm [11] & \multicolumn{2}{c|}{ imm[19:12] } & \multicolumn{2}{c|}{ rd } & opcode\\ \hline
\end{tabular}
\end{table}

\begin{itemize}
\item délka a typ instrukce (R,I,S,B,U,J) je určen 7-bity opcode
\item rs1,2 -- registery zdroje -- source; rd -- register cíle -- destination
\begin{itemize}
\item registry jsou vždy na pevné pozici v instrukci
\end{itemize}
\item immediate -- konstanty použité pro operaci nebo skoky
\item fnct3, fnct7 -- specifikace prováděné operace, např. sčítání, odčítání, posuny, atd.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Kódování instrukcí procesoru RISC-V}

Význam hodnot opcode:
\begin{table}
\footnotesize
\begin{tabular}{|c|l|l|}\hline
Opcode & Skupina operací & Skutečná operace \\ \hline
0110011 & Typ R podle fnct & add, sub, slt, or, and \\ \hline
0010011 & Typ I podle fnct & addi, subi, slt, or, and \\ \hline
0000011 & Čtení z paměti & lw \\ \hline
0100011 & Zápis do paměti & sw \\ \hline
1100011 & Větvení -- branch & beq \\ \hline
1101111 & Podprogramy & jal \\ \hline
1100111 & Návrat z podprogramu & jalr \\ \hline
0000111 & Načtení horní části konstanty & lui \\ \hline
\end{tabular}
\end{table}

\begin{table}
\footnotesize
\begin{tabular}{|l|l|l|}\hline
fnct7 & fnct3 & Skutečná operace \\ \hline
0000000 & 000  & add \\ \hline
0100000 & 000  & sub \\ \hline
0000000 & 010  & slt \\ \hline
0000000 & 110  & bitový or \\ \hline
0000000 & 111  & bitový and \\ \hline
\end{tabular}
\end{table}

\end{frame}


\begin{frame}
\frametitle{Stavební bloky procesoru}

\begin{table}
\footnotesize
\begin{tabular}{m{1.6cm} m{10cm}}
\hfill \includegraphics[width=0.6cm]{registr.pdf} & jeden registr, zápis řízen hodinovým signálem CLK \\ 
\hfill \includegraphics[width=1.6cm]{registry.pdf} & množina 32 registrů, podle vstupu A1, A2 vybere hodnoty těchto dvou registrů na výstup RD1 a RD2; pokud přijde hodinový signál a je nastaven vstup WE3 (write enable) tak se hodnota WD3 zapíše do registru A3 \\
\end{tabular}
\end{table}

\end{frame}



\begin{frame}
\frametitle{Hardwarová realizace registru}

Základní realizace registru pomocí tzv. obvodu d-latch
\begin{center}
\includegraphics[width=0.5\textwidth]{d_latch.pdf}
\end{center}

Tento obvod je velkou změnou oproti dosavadnímu přístupu, protože se zde objevuje cyklus -- výstup hradla je vstupem stejného hradla, nebo vstupem hradla jehož výstup je vstupem prvního hradla.

Co to tedy dělá?

\end{frame}

\begin{frame}
\frametitle{Hardwarová realizace registru}

Chování obvodu je určeno hodnotou vstupu E.

Nejdříve se podíváme, co se děje při E=1:
\begin{columns}
\begin{column}{0.45\textwidth}
\begin{center}
\includegraphics[width=0.9\textwidth]{d_latch_e1.pdf}
\end{center}
\end{column}
\begin{column}{0.5\textwidth}  
\begin{itemize}
\item Vstup D se zpožděním objeví na výstupu Q
\end{itemize}
\end{column}
\end{columns}

\end{frame}

\begin{frame}
\frametitle{Hardwarová realizace registru}

Pokud je E=0:
\begin{columns}
\begin{column}{0.45\textwidth}
\begin{center}
\includegraphics[width=0.9\textwidth]{d_latch_e0.pdf}
\end{center}
\end{column}
\begin{column}{0.5\textwidth}  
\begin{itemize}
\item Hodnota $Q,\overline{Q}$ závisí pouze na staré hodnotě dvojice $Q,\overline{Q}$
\item Dvojice nabývá pouze hodnot, která mohla vzniknout při zápisu, tedy buď $Q=1,\overline{Q}=0$ nebo $Q=0,\overline{Q}=1$
\end{itemize}
\end{column}
\end{columns}

\end{frame}

\begin{frame}
\frametitle{Hardwarová realizace základního cyklu CPU}

\begin{center}
\includegraphics[width=0.65\textwidth]{cpu_step.pdf}
\end{center}

Při náběžné hraně hodin (signál CLK) se do registru PC uloží nová hodnota PC+4. Tím se automaticky rozběhne nové čtení z paměti a následné zpracování instrukce, které si ukážeme později.
\end{frame}


\begin{frame}
\frametitle{Instrukce lw -- load word}

\textbf{\texttt{lw -- load word}} načti slovo z paměti do registru

\begin{tabular}{|l|l|}\hline
Popis & Načte slovo do registru ze zadané adresy z paměti \\ \hline
Operace & \texttt{[rd]} $\leftarrow$ \texttt{Mem[[rs]+imm12]} \\ \hline
Syntax & lw rd, imm12(rs) \\ \hline
Kódování & \texttt{iiii iiii iiii ssss s010 dddd d000 0011} \\ \hline
\end{tabular}

\bigskip

Příklad: Načtěte 32-bitové slovo z paměti z adresy 0x400 do registru 2:\\
\textbf{\texttt{lw x2, 0x400(x0)}}

\textbf{\texttt{iiii iiii iiii}}\phantom{xx}\textbf{\texttt{ssss s}}\hspace{0.1cm}\textbf{\texttt{010\hspace{0.25cm}dddd d\hspace{0.05cm}000 0011}}\\
\underbrace{\textbf{\texttt{0100 0000 0000}}}_{0x400}\texttt{ }\underbrace{\textbf{\texttt{0000 0}}}_{0}\underbrace{\textbf{\texttt{010}}}_{func3}\phantom{i}\underbrace{\textbf{\texttt{0001 0}}}_{2}\underbrace{\textbf{\texttt{000 0011}}}_{opcode}\\

\textbf{\texttt{0x 40 00 21 03}} -- kód pro instrukci \textbf{\texttt{lw x2, 0x400(x0)}}

Poznámka: Registr x0 má natvrdo hodnotu 0, kterou nelze změnit

\end{frame}

\begin{frame}[shrink=15]
\frametitle{Implementace instrukce lw}

\textbf{\texttt{lw}}: \texttt{rs1} -- základní adresa, \texttt{imm12} -- posunutí adresy, \texttt{rd} -- registr, kam se uloží data z paměti

\bigskip

\begin{tabular}{|l|l|l|l|l|l|}\hline
I & \textbf{\texttt{imm(12)}}, 31:20 & \textbf{\texttt{rs1(5)}}, 19:15 & \textbf{\texttt{func3}}, 14:12 & \textbf{\texttt{rd(5)}}, 11:7 & \textbf{\texttt{opcode(7)}}, 6:0 \\ \hline
\end{tabular}

\bigskip

\begin{center}
\includegraphics[width=0.90\textwidth]{cpu-load.pdf}
\end{center}

\end{frame}

\begin{frame}[shrink=15]
\frametitle{Implementace instrukce lw}

\textbf{\texttt{lw}}: \texttt{rs1} -- základní adresa, \texttt{imm12} -- posunutí adresy, \texttt{rd} -- registr, kam se uloží data z paměti

\bigskip

\begin{tabular}{|l|l|l|l|l|l|}\hline
I & \textbf{\texttt{imm(12)}}, 31:20 & \textbf{\texttt{rs1(5)}}, 19:15 & \textbf{\texttt{func3}}, 14:12 & \textbf{\texttt{rd(5)}}, 11:7 & \textbf{\texttt{opcode(7)}}, 6:0 \\ \hline
\end{tabular}

Zápis proběhna na rostoucí hranu hodin.

\begin{center}
\includegraphics[width=0.90\textwidth]{cpu-load-red.pdf}
\end{center}



\end{frame}


\begin{frame}[shrink=15]
\frametitle{Implementace instrukce lw}

\textbf{\texttt{lw}}: \texttt{rs1} -- základní adresa, \texttt{imm12} -- posunutí adresy, \texttt{rd} -- registr, kam se uloží data z paměti

\bigskip

\begin{tabular}{|l|l|l|l|l|l|}\hline
I & \textbf{\texttt{imm(12)}}, 31:20 & \textbf{\texttt{rs1(5)}}, 19:15 & \textbf{\texttt{func3}}, 14:12 & \textbf{\texttt{rd(5)}}, 11:7 & \textbf{\texttt{opcode(7)}}, 6:0 \\ \hline
\end{tabular}

\bigskip

\begin{center}
\includegraphics[width=0.88\textwidth]{cpu-load2.pdf}
\end{center}
\end{frame}


\begin{frame}
\frametitle{QtRvSim - RISC-V Simultaor}

\includegraphics[width=0.9\textwidth]{simulator.pdf}

\end{frame}



\begin{frame}
\frametitle{Instrukce sw -- store word}

\textbf{\texttt{sw -- store word}} ulož slovo z registru do paměti

\bigskip

\begin{tabular}{|l|l|}\hline
Popis & Uloží slovo z registru rs2 do zadané adresy z paměti \\ \hline
Operace & \texttt{Mem[[rs1]+imm12]} $\leftarrow$ \texttt{[rs2]} \\ \hline
Syntax & sw rs2, imm12(rs1) \\ \hline
Kódování & \texttt{iiii iiit tttt ssss s010 iiii i010 0011} \\ \hline
\end{tabular}

\bigskip

Příklad: Načtěte 32-bitové slovo z paměti z adresy 0x400 do registru 2:\\
\textbf{\texttt{lw x2, 0x400(x0)}}

\textbf{\texttt{iiii iii\hspace{0.08cm}t tttt}}\phantom{xx}\textbf{\texttt{ssss s}}\hspace{0.1cm}\textbf{\texttt{010\hspace{0.25cm}dddd d\hspace{0.05cm}010 0011}}\\
\underbrace{\textbf{\texttt{0100 000}}}_{0x40\_}
\underbrace{\textbf{\texttt{0 0010}}}_{2}
\texttt{ }\underbrace{\textbf{\texttt{0010 1}}}_{5}
\underbrace{\textbf{\texttt{010}}}_{func3}\phantom{i}\underbrace{\textbf{\texttt{0010 0}}}_{0x \_04}
\underbrace{\textbf{\texttt{010 0011}}}_{opcode}\\

\textbf{\texttt{0x 40 22 a2 23}} -- kód pro instrukci \textbf{\texttt{sw x2, 0x404(x5)}}

\end{frame}

\begin{frame}[shrink=18]
\frametitle{Implementace instrukce sw}

\textbf{\texttt{sw}}: \texttt{rs1} -- základní adresa, \texttt{imm12} -- posunutí adresy, \texttt{rs2} -- registr, který se uloží do paměti

\bigskip

\begin{tabular}{|l|l|l|l|l|l|}\hline
S & \textbf{\texttt{imm(12)}},31:25,11:7 & \textbf{\texttt{rs2(5)}},24:20 & \textbf{\texttt{rs1(5)}},19:15 & \textbf{\texttt{func3}},14:12 & \textbf{\texttt{opcode(7)}},6:0 \\ \hline
\end{tabular}

\bigskip

\includegraphics[width=0.90\textwidth]{cpu-store2.pdf}

\end{frame}




\begin{frame}
\frametitle{Instrukce add -- sečti dva registry}

\textbf{\texttt{add -- addition}} -- sečti hodnoty dvou registrů a součet ulož do registru

\bigskip

\begin{tabular}{|l|l|}\hline
Popis & Sečti hodnoty z registrů rs1 a rs2 a výsledek ulož do rd \\ \hline
Operace & \texttt{[rd]} $\leftarrow$ \texttt{[rs1] + [rs2]} \\ \hline
Syntax & add rd, rs1, rs2 \\ \hline
Kódování & \texttt{0000 000t tttt ssss s010 dddd d011 0011} \\ \hline
\end{tabular}

\bigskip

Příklad: Sečti hodnoty z registru 2 a registru 3, výsledek ulož do registru 4:\\
\textbf{\texttt{add x4, x2, x3}}

\textbf{\texttt{0000 000\hspace{0.08cm}t tttt}}\phantom{xx}\textbf{\texttt{ssss s}}\hspace{0.1cm}\textbf{\texttt{010\hspace{0.25cm}dddd d\hspace{0.05cm}010 0011}}\\
\textbf{\texttt{0000 000}}
\underbrace{\textbf{\texttt{0 0011}}}_{3}
\texttt{ }\underbrace{\textbf{\texttt{0001 0}}}_{2}
\underbrace{\textbf{\texttt{010}}}_{func3}\phantom{i}
\underbrace{\textbf{\texttt{0010 0}}}_{4}
\underbrace{\textbf{\texttt{011 0011}}}_{opcode}\\

\textbf{\texttt{0x 00 31 02 33}} -- kód pro instrukci \textbf{\texttt{add x4, x2, x3}}


\end{frame}

\begin{frame}[shrink=25]
\frametitle{Implementace instrukce add}

\textbf{\texttt{add}}: \texttt{rs1}, \texttt{rs2} -- sčítance, \texttt{rd} -- registr, kam se uloží součet

\bigskip

\begin{tabular}{|l|l|l|l|l|l|l|}\hline
R & \textbf{\texttt{func(7)}},31:25 & \textbf{\texttt{rs2(5)}},24:20 & \textbf{\texttt{rs1(5)}},19:15 & \textbf{\texttt{func3}},14:12 & \textbf{\texttt{rd(5)}},11:7 & \textbf{\texttt{opcode(7)}},6:0 \\ \hline
\end{tabular}

\bigskip

\includegraphics[width=0.85\textwidth]{cpu-add.pdf}

\end{frame}


\begin{frame}
\frametitle{Implementace instrukce sub, amd, or, slt}

Jediný rozdíl oproti instrukci sčítání add je v hodnotě ALUControl, který vybírá, jakou operaci jednotka ALU provede. Cesta dat a uložení výsledku je stejná jako u sčítání.
\bigskip

\bigskip

\includegraphics[width=0.85\textwidth]{cpu-add2.pdf}

\end{frame}


\begin{frame}[shrink=10]
\frametitle{Implementace instrukcí addi, ori, andi}

\textbf{\texttt{addi -- add immediate}}: \texttt{[rd]} $\leftarrow$ \texttt{[rs1] + imm12} -- přičte k hodnotě registru \texttt{rs1} konkrétní číslo \texttt{imm} a výsledek uloží do registru \texttt{rd}

\bigskip

\begin{tabular}{|l|l|l|l|l|l|}\hline
I & \textbf{\texttt{imm(12)}},31:20 & \textbf{\texttt{rs1(5)}},19:15 & \textbf{\texttt{func3}},14:12 & \textbf{\texttt{rd(5)}},11:7 & \textbf{\texttt{opcode(7)}},6:0 \\ \hline
\end{tabular}

\bigskip

\includegraphics[width=0.85\textwidth]{cpu-addi.pdf}

\end{frame}


\begin{frame}[shrink=15]
\frametitle{Implementace instrukce skoku beq}

\textbf{\texttt{beq -- branch if equal}}: \texttt{[pc]} $\leftarrow$ \texttt{[pc] + SignImm} -- přičte k hodnotě registru \texttt{pc} konkrétní znaménkové číslo rozšířené na 32 bitů \texttt{imm} a výsledek uloží do registru \texttt{pc} pokud nastala rovnost hodnot v registrech rs1 a rs2.

\bigskip

\begin{tabular}{|l|l|l|l|l|l|}\hline
S & \textbf{\texttt{imm(12)}},31:25, 11:7 & \textbf{\texttt{rs2(5)}},24:20 & \textbf{\texttt{rs1(5)}},19:15 & \textbf{\texttt{func3}},14:12 & \textbf{\texttt{opcode(7)}},6:0 \\ \hline
\end{tabular}

\bigskip

\includegraphics[width=0.85\textwidth]{cpu-beq.pdf}

\end{frame}


\begin{frame}
\frametitle{Rychlost CPU}

\bigskip

\includegraphics[width=0.85\textwidth]{cpu-time.pdf}

\end{frame}


\begin{frame}
\frametitle{Control Unit}

\bigskip

\includegraphics[width=0.85\textwidth]{cpu-control-unit.pdf}

\end{frame}


\end{document}

